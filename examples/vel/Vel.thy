(*

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 
 *)

theory Vel
  imports "../../isabelle/Presimplified_Semantics_Manual2"
          "HOL-Library.Rewrite"
          "../../isabelle/Monads/Abstract_System"
begin


text \<open>Load the vel.s file.\<close>
x86_64_parser "../examples/vel/vel_opt.s"
lemmas vel_opt.assembly_def [code]

text \<open>
  A Floyd invariant is a partial map from locations to state predicates.
  A location consists of a tuple (ts, pc) which stores the current text section and the program
  counter.
\<close>
type_synonym floyd_invar = \<open>64 word \<rightharpoonup> (state \<Rightarrow> bool)\<close>

text \<open>
  We use a locale to quantify over any @{term l}, i.e, any assignment of addresses to labels.
  This locale extends the vel locale generated by the parser.
\<close>
locale vel = "vel_opt" + presimplified_semantics +
  fixes ret_address :: "64 word"
    and current_speed
    and current_braking_force
    and current_accel_force
  assumes get_current_velocity[simp]: "funcs ''get_current_velocity'' \<equiv> Some (write_reg (General SixtyFour ymm0w0) current_speed)"
      and get_current_braking_force[simp]: "funcs ''get_current_braking_force'' \<equiv> Some (write_reg (General SixtyFour ymm0w0) current_braking_force)"
      and get_current_accel_force[simp]: "funcs ''get_current_accel_force'' \<equiv> Some (write_reg (General SixtyFour ymm0w0) current_accel_force)"
assumes ret_address: "outside ret_address 204 279"
begin

abbreviation "\<alpha> \<equiv> assembly"

lemma binary_offset[simp]:
  shows "binary_offset assembly = boffset"
  by (simp add: assembly_def assembly.defs)
schematic_goal unfold_labels[simp]:
  shows "label_to_address assembly = ?x"
  apply (rule ext)
  apply (unfold label_to_address_def)
  apply (unfold binary_offset)
  by (auto simp add: label_to_address_def assembly_def assembly.defs)

fun vel_flag_annotation :: flag_annotation where \<comment> \<open>Unused\<close>
  \<open>vel_flag_annotation loc = {}\<close>

text \<open>
  The step function fetches the next instruction and executes it.
  This matches exactly what method rewrite\_one\_instruction is able to rewrite.
\<close>
definition step :: \<open>(unit, state) se\<close> where
  \<open>step \<sigma> \<equiv>
    let  pc = get_rip \<sigma>;
         index = the (instr_index lookup_table boffset pc) in
    let' (_,i,s) = (text_sections \<alpha>)!index;
         \<sigma> = exec_instr \<alpha> semantics vel_flag_annotation i s \<sigma>
    in
      Some ((), \<sigma>)\<close>

lemma wps_stepI[wps_intros]:
  assumes \<open>
     let  pc = get_rip \<sigma>;
          index = the (instr_index lookup_table boffset pc) in
     let' (_,i,s) = (text_sections \<alpha>)!index;
          \<sigma> = exec_instr \<alpha> semantics vel_flag_annotation i s \<sigma>
    in
             Q () \<sigma>\<close>
  shows \<open>wps step Q \<sigma>\<close>
  using assms
  unfolding step_def
  by (auto simp add: Let'_def Let_def wps_def)

definition halted :: \<open>state \<Rightarrow> bool\<close> where
  \<open>halted \<sigma> = (get_rip \<sigma> = boffset + 279)\<close>
declare halted_def[simp]

definition wf_state :: \<open>state \<Rightarrow> bool\<close> where
  \<open>wf_state _ = True\<close>
declare wf_state_def[simp]

sublocale cfg_system step \<open>halted\<close> wf_state get_rip
  by standard (simp add: det_system.is_weak_invar_def)

abbreviation float_le :: "64 word \<Rightarrow> 64 word \<Rightarrow> bool" (infix "\<le>\<^sup>f" 50)
  where "x \<le>\<^sup>f y \<equiv> float_ucmp x y \<in> {Unordered, LT, EQ}"


text \<open>The Floyd invariant expresses for some locations properties that are invariably true.\<close>
definition pp_\<Theta> :: \<open>_ \<Rightarrow> floyd_invar\<close>
  where \<open>pp_\<Theta> rsp\<^sub>0 \<equiv>
  let v = current_accel_force -\<^sup>f current_braking_force div\<^sup>f 0x408F400000000000 *\<^sup>f 0xFCA9F1D24D62503F
             +\<^sup>f current_speed in
  [
  (* The precondition of the program: *)
  (boffset + 204) \<mapsto> (\<lambda>\<sigma>.
                 RSP \<sigma> = rsp\<^sub>0
               \<and> \<sigma> \<turnstile> *[250 + boffset + 292,8] = (0x408F400000000000::64 word)
               \<and> \<sigma> \<turnstile> *[258 + boffset + 292,8] = (0xFCA9F1D24D62503F::64 word)
               \<and> \<sigma> \<turnstile> *[266 + boffset + 292,8] = (0xE63FA4DFBE0E4D40::64 word)
               \<and> 0xE63FA4DFBE0E4D40 \<le>\<^sup>f v
            ),
  (* The postcondition *)
  (boffset + 279) \<mapsto> (\<lambda>\<sigma>. regs \<sigma> ymm0w0 = v)
  ]\<close>

method symbolic_execution uses masters add del =
  (rule wps_rls),
  (simp (no_asm_simp) add: add step_def lookup_table_def instr_index_def entry_size_def del: del),
  (rewrite_one_let' del: del add: add assembly_def),
  (simp add: exec_instr_def),
  (subst presimplify),
  (rewrite_one_let' del: del add: add),
  (subst is_manual),
  ((insert masters)[1]),
  (rewrite_one_let' del: del add: add)+,
  ((thin_tac \<open>master _ _ _\<close>)+)?,
  rule linvar_unfoldI,
  (simp (no_asm_simp) add: spec_of_outside add del: del)

method restart_symbolic_execution uses add del =
  ((rewrite_one_let' add: add del: del)+,
  (thin_tac \<open>master _ _ _\<close>)+,
  rule linvar_unfoldI,
  (simp (no_asm_simp) add: spec_of_outside add del: del))
|
  (((thin_tac "master _ _ _")+)?,
  rule linvar_unfoldI,
  (simp (no_asm_simp) add: spec_of_outside add del: del))

method finish_symbolic_execution uses add del masters =
  (insert masters,
   simp add: simp_rules add del: del,
   (rewrite_one_let' add: add del: del)+,
   (simp add: simp_rules add: add del: del)?,
   ((thin_tac "master _ _ _")+)?)


text \<open>Add some rules to the simplifier to simplify proofs.\<close>
schematic_goal pp_\<Theta>_zero[simp]:
  shows \<open>pp_\<Theta> rsp\<^sub>0 boffset = ?x\<close>
  unfolding pp_\<Theta>_def
  by simp
schematic_goal pp_\<Theta>_numeral_l[simp]:
  shows \<open>pp_\<Theta> rsp\<^sub>0 (n + boffset) = ?x\<close>
  unfolding pp_\<Theta>_def
  by simp
schematic_goal pp_\<Theta>_numeral_r[simp]:
  shows \<open>pp_\<Theta> rsp\<^sub>0 (boffset + n) = ?x\<close>
  unfolding pp_\<Theta>_def
  by simp



lemma rewrite_vel:
  assumes \<open>seps blocks\<close>
      and \<open>master blocks (rsp\<^sub>0 - 8, 8) 1\<close>
      and \<open>master blocks (rsp\<^sub>0 - 16, 8) 2\<close>
      and \<open>master blocks (rsp\<^sub>0 - 24, 8) 3\<close>
      and \<open>master blocks (boffset + 542, 8) 4\<close>
      and \<open>master blocks (boffset + 550, 8) 5\<close>
      and \<open>master blocks (boffset + 558, 8) 6\<close>
    shows \<open>is_std_invar (floyd.invar (pp_\<Theta> rsp\<^sub>0))\<close>
proof -
  (* Boilerplate code for setting up the master blocks: *)
  note masters = assms(2-7)

  show ?thesis
    (* Boilerplate code from Peter to start the VCG *)
    apply (rule floyd_invarI)
    apply (rewrite at \<open>floyd_vcs \<hole> _\<close> pp_\<Theta>_def)
    apply (subst Let_def)
    apply (intro floyd_vcsI; clarsimp?)

    (* Subgoal for (ts, pc) = (6, 0) to (6, 14) *)
    subgoal premises prems for \<sigma>
    proof -
      show ?thesis
        (* Insert relevant knowledge *)
        thm prems(1,3-)
        thm prems(2)[symmetric]
        apply (insert prems(1,3-) prems(2)[symmetric] assms(1))
        (* Apply VCG / symb. execution *)
        apply (symbolic_execution masters: masters) (* sub *)
        apply (symbolic_execution masters: masters) (* call *)
        apply (symbolic_execution masters: masters) (* movsd *)
        apply (symbolic_execution masters: masters) (* call *)
        apply (symbolic_execution masters: masters) (* movsd *)
        apply (symbolic_execution masters: masters) (* call  *)
        apply (symbolic_execution masters: masters) (* subsd *)
        apply (symbolic_execution masters: masters) (* divsd *)
        apply (symbolic_execution masters: masters) (* mulsd *)
        apply (symbolic_execution masters: masters) (* addsd *)
        apply (symbolic_execution masters: masters) (* ucomisd *)
        apply (symbolic_execution masters: masters) (* ja	.label_24 *)
        apply (auto simp add: field_simps)[1]
        apply (restart_symbolic_execution)
        apply (symbolic_execution masters: masters) (* cvttsd2si *)
        apply (symbolic_execution masters: masters) (* add *)
        apply (auto simp add: field_simps)[1]
        done
    qed
    done
qed

thm rewrite_vel

end

end
